import ast
import re


def preprocess_string(s):
    # 改行をエスケープ
    s = s.replace("\n", "\\n")
    # 文字列内のシングルクォートとバックスラッシュをエスケープ
    s = s.replace("\\", "\\\\").replace("'", "\\'")
    return s


# データダンプ文字列（実際の内容に応じて変更）
# データダンプ文字列
data_dump = """
{'data': [ThreadMessage(id='msg_Mqa8b2sFk5raFI8KgL2pu1FT', assistant_id='asst_9hzHwAHa7JLAzeMNr2b81YnX', content=[MessageContentImageFile(image_file=ImageFile(file_id='file-LkzUHc0wc9vvVkQTCCbn8lVl'), type='image_file'), MessageContentText(text=Text(annotations=[], value='円グラフ（パイチャート）は、`geo`フィールドに基づく地域ごとのロケーションの割合を示しています。個々のスライスは、それぞれの地域の総ロケーション数が全体の中で占める割合を表しており、データの地域的分布をより直感的に理解するのに役立ちます。\n\nこれで、データの概要と特性を理解するための3つの異なるデータ可視化を完成しました。これらの可視化は、データの傾向と分布を把握するのに有効な手段です。もしこのデータセットに関して他に分析や可視化を行う必要がある場合、またはご質問があればお知らせください。'), type='text')], created_at=1702271991, file_ids=[], metadata={}, object='thread.message', role='assistant', run_id='run_q2WfzPAMrLliL7aWl8FFRKfZ', thread_id='thread_VyZrAeU7CoUUFL6GxPNRgpNz'), ThreadMessage(id='msg_jkYp7Ez6itYXHGYTRRxdR0ix', assistant_id='asst_9hzHwAHa7JLAzeMNr2b81YnX', content=[MessageContentImageFile(image_file=ImageFile(file_id='file-GAd4kdLDZAuSJpPU9teZXYuR'), type='image_file'), MessageContentText(text=Text(annotations=[], value='棒グラフ（バーチャート）は、各国における`locationIdentifier`の数を表示しています。これにより、このデータセットにおける地理的分布と、特定の国におけるロケーションの集中度を視覚的に把握できます。\n\n最後に、`geo`フィールドに基づき地域ごとのロケーション数を表示する円グラフ（パイチャート）を作成しましょう。'), type='text')], created_at=1702271971, file_ids=[], metadata={}, object='thread.message', role='assistant', run_id='run_q2WfzPAMrLliL7aWl8FFRKfZ', thread_id='thread_VyZrAeU7CoUUFL6GxPNRgpNz'), ThreadMessage(id='msg_KRHzV45gnJu5waSIvYKS2AAZ', assistant_id='asst_9hzHwAHa7JLAzeMNr2b81YnX', content=[MessageContentImageFile(image_file=ImageFile(file_id='file-SameKEP5sKDxVosspdizdtxF'), type='image_file'), MessageContentText(text=Text(annotations=[], value='棒グラフ（バーチャート）は、`locationType`の異なる種類ごとにロケーションの数を表示しています。これにより、このデータセットにおける各`locationType`の割合や傾向を視覚的に捉えることができます。\n\n次に、各国の`locationIdentifier`の数を集計して表示する地図上のバブルチャートを作成します。これには、地理情報を用いた可視化ライブラリが必要ですが、このセッションではインターネットアクセスが無効になっており、地図情報を提供する第三者のサービス（例えば、BasemapやGeoPandas）にアクセスできません。したがって、代わりに国ごとの`locationIdentifier`の数を可視化する棒グラフで近似することができます。\n\nそれを行ってみましょう。'), type='text')], created_at=1702271946, file_ids=[], metadata={}, object='thread.message', role='assistant', run_id='run_q2WfzPAMrLliL7aWl8FFRKfZ', thread_id='thread_VyZrAeU7CoUUFL6GxPNRgpNz'), ThreadMessage(id='msg_U73355INZJRWY2hkkyXE7Zb3', assistant_id='asst_9hzHwAHa7JLAzeMNr2b81YnX', content=[MessageContentText(text=Text(annotations=[], value='ファイルはCSV形式のようです。このCSVファイルには、以下のようなカラムが含まれています：\n\n- locationIdentifier\n- locationType\n- locationName\n- address1\n- address2\n- city\n- postalCode\n- stateProvince\n- country\n- coordinates\n- includeInCorrelation\n- geo\n- locationSubType\n- sourceLink\n\nこのデータを使って3つの異なる可視化を行うには、データの特性を活かした可視化を選ぶ必要があります。以下の3つの可視化を提案します：\n\n1. locationTypeに基づくデータの分布を示す棒グラフ（バーチャート）\n2. 各国のlocationIdentifierの数を集計して表示する地図上のバブルチャート\n3. geoフィールドを基にしたグループ別のlocationNumberの合計を示す円グラフ（パイチャート）\n\nこれらの可視化は、データの地理的分布、供給業者や運営拠点の種類、地域ごとのエントリの数など、データセットの異なる側面を表しています。\n\nまずはlocationTypeに基づく棒グラフから作成しましょう。その後、残りの2つの可視化を行います。'), type='text')], created_at=1702271912, file_ids=[], metadata={}, object='thread.message', role='assistant', run_id='run_q2WfzPAMrLliL7aWl8FFRKfZ', thread_id='thread_VyZrAeU7CoUUFL6GxPNRgpNz'), ThreadMessage(id='msg_TrrNpbD6009aqMfeAiKZKveQ', assistant_id='asst_9hzHwAHa7JLAzeMNr2b81YnX', content=[MessageContentText(text=Text(annotations=[], value="ファイルの最初の数バイトに基づくと、このファイルはテキストベースの形式（おそらくCSVまたは類似の区切り文字）であることが示唆されます。ファイルの最初の文字が `'\\xef\\xbb\\xbf'` であることから、これはUTF-8のバイトオーダーマーク（BOM）である可能性があります。\n\n次に、ファイルの最初の数行を読み込んで、実際にCSV形式であるかどうかを確認します。そして、ファイルの内容に応じて適切なデータ可視化を検討します。"), type='text')], created_at=1702271886, file_ids=[], metadata={}, object='thread.message', role='assistant', run_id='run_q2WfzPAMrLliL7aWl8FFRKfZ', thread_id='thread_VyZrAeU7CoUUFL6GxPNRgpNz'), ThreadMessage(id='msg_0NjV4UOSgg85w6aXaWx8AnhS', assistant_id='asst_9hzHwAHa7JLAzeMNr2b81YnX', content=[MessageContentText(text=Text(annotations=[], value='ファイルの内容をまず確認し、そのデータの傾向に基づいて適切なデータ可視化を作成するためには、ファイルの形式を特定し、中身を読み込む必要があります。ファイルには拡張子がないため、まずはファイルの形式を推測し、中身を調べてみましょう。\n\nファイルを読み込んで中身を確認してから、データの特徴を基にして3つのデータ可視化を作成します。'), type='text')], created_at=1702271865, file_ids=[], metadata={}, object='thread.message', role='assistant', run_id='run_q2WfzPAMrLliL7aWl8FFRKfZ', thread_id='thread_VyZrAeU7CoUUFL6GxPNRgpNz'), ThreadMessage(id='msg_zJM157ANSw7yuIzCMLiiuOac', assistant_id=None, content=[MessageContentText(text=Text(annotations=[], value='このファイルの傾向に基づいて、3つのデータ可視化を作成する。'), type='text')], created_at=1702271863, file_ids=['file-SbS0cUBhyce1BNSlgJNw2Kmu'], metadata={}, object='thread.message', role='user', run_id=None, thread_id='thread_VyZrAeU7CoUUFL6GxPNRgpNz')], '_model': <class 'openai.types.beta.threads.thread_message.ThreadMessage'>, '_client': <openai.OpenAI object at 0x100307dc0>, '_options': FinalRequestOptions(method='get', url='/threads/thread_VyZrAeU7CoUUFL6GxPNRgpNz/messages', params={}, headers={'OpenAI-Beta': 'assistants=v1'}, json_data=None, max_retries=NOT_GIVEN, timeout=NOT_GIVEN, files=None, idempotency_key=None, post_parser=<function SyncAPIClient._request_api_list.<locals>._parser at 0x1025f97e0>, extra_json=None)}
"""

# 文字列の前処理
processed_data_dump = preprocess_string(data_dump)

# 文字列を辞書に変換
data_dict = ast.literal_eval(processed_data_dump)

# 変換された辞書を出力
print(data_dict)
